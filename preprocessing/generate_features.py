import os
import numpy as np
import pandas as pd
from dateutil import parser

project_root = os.path.dirname(
    os.path.abspath(__file__)) + "/" + os.pardir + "/"
data_dir = project_root + "data/"


class FeatureGenerator:
    def __init__(self, data, labels, sensors, target=None):
        """
        data: pandas DataFrame (generated by pickle_to_hdf.py and fixed by a
        fuckton of other scripts)
        labels: pandas DataFrame (measurements.csv)
        sensors: the sensors we care about (af1-sensors.csv)
        target: save location of the new dataset
        """
        # self.data_h5 = data_h5
        self.data = data
        # Convert timestamps to datetime objects for future comparisons
        labels = self.df_string_to_datetime(labels)
        self.labels = dict(  # allows us to access labels by ID
            [(key, df) for key, df in labels.groupby("BLUETOOTHADDRESS")])

        self.sensors = sensors["ID"]
        if target is None:
            target = data_dir + "training-data.csv"

        self.target = target

    def df_string_to_datetime(self,
                              df,
                              columns=["START_TIMESTAMP", "END_TIMESTAMP"]):
        for column in columns:
            series = df[column]
            series = series.map(lambda x: parser.parse(x, dayfirst=False))
            df[column] = series

        return df

    def generate_features(self, df, label, key):
        index = df.index
        areas = np.zeros(len(index), dtype=np.int64)
        devices = np.zeros(len(index), dtype=np.int64) + int(key)

        features = pd.DataFrame(index=index)
        sensor_dict = {}
        for id in self.sensors:
            sensor_dict[id] = np.zeros(len(index), dtype=np.int64)

        for i, timestamp in enumerate(df.index):
            current_area = self.get_area(label, timestamp)
            if current_area is None:
                return None
                # print(label)
                # input()
            areas[i] = current_area
            row = df[df.index == timestamp]
            sensor_id = row["SensorID"].values[0]
            rssi = row["MaxRSSI"].values[0]
            sensor_dict[sensor_id][i] = rssi

        for key in sensor_dict:
            features[key] = sensor_dict[key]

        features["Device"] = devices
        features["areas"] = areas
        # print("Key:", key)
        # print("Shape:", features.shape)
        # input()
        return features

    def get_area(self, label, timestamp):
        """
        There are two transitions in the labels;
        the point at which someone enters and leaves area 1;
        the point at which someone enters and leaves area 2.
        If a timestamp precedes the enter time of
        area 1, we assume the device is in area 0.
        If a timestamp supercedes the leaving time of
        area 2, we assume the device is in area 3.
        """
        start = "START_TIMESTAMP"
        end = "END_TIMESTAMP"

        transition_1 = label[label["START_POINT_SEQ_NUMBER"] == 1]
        transition_2 = label[label["START_POINT_SEQ_NUMBER"] == 2]
        # sanity check
        if (timestamp.day is not transition_1[start].iloc[0].day):
            # print(timestamp)
            # print(transition_1[start].iloc[0])
            # print(transition_1)
            # print(transition_2)
            # print("These labels are weird mang")
            return None

        # We use .any() here because transition 1 and 2 are singleton lists, so
        # we get a list of length 1 of truth values.
        if (timestamp < transition_1[start]).any():
            area = 0
        elif (timestamp < transition_1[end]).any():
            area = 1
        elif (timestamp < transition_2[end]).any():
            area = 2
        else:
            area = 3

        # print(timestamp)
        # print(transition_1[start])
        # print(transition_1[end])
        # print(transition_2[end])
        # print(area)
        # input()

        return area

    def generate_features(self, chunksize=1000):
        """
        chunksize defines how many df rows should be loaded into memory from
        the hdf file at once
        """
        keys = self.labels.keys()
        num_keys = len(keys)
        feature_set = None
        # data_keys = list(set([key for key in self.data['DeviceID']]))
        i = 0
        skipped_keys = 0
        missing_labels = 0

        # for i, key in enumerate(data_keys):
        for key, df in self.data.groupby('DeviceID'):

            # df = self.data_h5[str(key)]
            if key not in self.labels:
                print("missing label for key", key)
                missing_labels += 1
                continue

            label = self.labels[key]

            features = self.generate_features(df, label, key)
            if features is None:
                print(df)
                print(label)
                input()
                print("skipped key", key)
                skipped_keys += 1
                continue
            if feature_set is None:
                feature_set = features
            else:
                feature_set = feature_set.append(features)

            print("Processed key {} of {}.".format(i + 1, num_keys))
            i = i + 1

        print("Done. Skipped {} keys.\nMissing label for {}\
                keys.".format(skipped_keys, missing_labels))

        feature_set.to_csv(data_dir + 'training-set.csv')

    def default():
        """
        returns a FeatureGenerator with reasonable defaults
        """
        print("Started initialization...")
        # data = pd.HDFStore(data_dir + "af1-fixed-dates.h5")
        # define our own date parser because pandas is confused or I'm dumb
        # probably the latter. In case of errors, verify dates
        data = pd.read_csv(
            data_dir + "fixedlolfixed.csv", parse_dates=True,
            date_parser=lambda date: pd.datetime.strptime(date, '%Y-%m-%d\
                %H:%M:%S'),
            index_col='DateTime')
        labels = pd.read_csv(data_dir + "simple-af1-labels.csv", index_col=0)
        sensors = pd.read_csv(data_dir + "af1-sensors.csv")
        fg = FeatureGenerator(data, labels, sensors)
        print("Finished initialization.")
        return fg


if __name__ == "__main__":
    fg = FeatureGenerator.default()
    fg.generate_features()
